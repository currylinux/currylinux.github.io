[{"categories":["Go语言学习"],"content":"1. 基础语法介绍(1) 首先演示操作在go语言中注释的用法,注释在编译的时候不会现实,因为都是给人看的.所以注释对编译是没有影响的,可以直接在vscode的控制台进行编译等操作. // 这里是main包 package main import \"fmt\" /* 这里是main函数 是程序的启动的入口 */ func main() // 我这里是输出Hello Wirld到控制台 fmt.Println(\"Hello World!!!\") } PS C:\\htgolang\\chapter01\u003e go build main.go PS C:\\htgolang\\chapter01\u003e .\\main.exe Hello World!!! PS C:\\htgolang\\chapter01\u003e 基本组成元素1-标识符 ⭐标识符是编程时所使用的名字,用于给变量、常量、函数、类型、 接口、包名等进行命名,以建立名称和使用之间的关系. ⭐Go语言标识符的命令规则: 只能由非字母(Unicode)、数字、下划线组成 只能以字母或下划线开 不能Go语言关键字 避免使用Go语言预定义标识符 建议使用驼峰式 标识符号区分大小写 基本组成元素2-关键字 ⭐关键字用于特性的语法结构 ⭐Go语言定义25关键字: 声明: import、package 实体声明和定义: chan、const、func、interface、map、struct、type、var 流程控制: break、case、continue、default、defer、else、fallthrough、for、go、goto、if、range、return、select、switch 基本组成元素3-字面量 ⭐字面量是值得表示方法、常用与对变量/变量进行初始化/ ⭐主要分为: 标识基础数据类型值得字面量,例如: 0, 1.1, true, 3 + 4i, ‘a’, “我爱中国” 构造自定义的复合数据类型的类型字面量,例如: type Interval int 用于表示符合数据类型值的复合字面量,用来构造array、slice、map、struct的值,例如:{1,2,3} 基本组成元素4-操作符 ⭐算术运算符: +、-、*、/、%、++、– ⭐关系运算符: \u003e、\u003e=、\u003c、\u003c=、==、!= ⭐逻辑运算符: \u0026\u0026、||、! ⭐位运算符: \u0026、|、^、«、»、\u0026^ ⭐赋值运算符: =、+=、-=、*=、/=、%=、\u0026=、|=、^=、«=、»= ⭐其他运算符: \u0026(单目)、*(单目)、.(点)、-(单目)、…、\u003c- 分隔符 ⭐小括号(), 中括号[], 大括号{}, 分号;, 逗号, 2. 基础知识点 基础知识点(一) – 声明 声明语句用于定义程序的各种实体对象,主要有: 声明变量的var 声明常量的const 声明函数的func 声明类型的type 基础知识点(一) – 变量 变量是指对一块存储空间定义名称,通过名称对存储空间的内容进行访问或修改,使用var进行变量声明,常用的语法为: 1. var 变量名 变量类型 = 值 (定义变量并进行初始化,例如: var name string = “silence”) 2. var 变量名 变量类型 (定义变量使用零值进行初始化.例如: var age int) 3. var 变量名 = 值 (定义变量,变量类型通过值类型进行推导,例如:var isBoy = true) 4. var变量名1,变量名2, …,变量名n 变量类型 (定义多个相同类型的变量并使用零值进行初始化,例如: var prefix, suffix string) 5. var变量名1,变量名2, …, 变量名n 变量类型 = 值1,值2, …, 值n (定义多个相同类型的变量并使用对应的值进行初始化,例如: var prev, next int = 3,4) 6. var变量名1,变量名2, …, 变量名n = 值1,值2, …, 值n (定义多个变量并使用对应的值进行初始化,变量的类型使用值类型进行推导,类型可不相同,例如: var name, age = “silence”, 30) 3.变量语法 变量语法演示1 package main import \"fmt\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名规则 1. 必须由非空的unicode字符串组成、数字、_ 2. 不能以数字开头 3. 不能为go的关键字(25个) 4. 避免和go预定义标识符冲突, true/false/nul/bool/string 5. 驼峰 6. 标识符区分大小写 */ var me string me = \"kk\" fmt.Println(me) } 写完之后,可以通过vscode的终端运行操作 go run vars.go,另外须知的是在函数内定义的变量,必须是要使用的. 变量语法演示2 #1 package main import \"fmt\" var version string = \"1.0\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名规则 1. 必须由非空的unicode字符串组成、数字、_ 2. 不能以数字开头 3. 不能为go的关键字(25个) 4. 避免和go预定义标识符冲突, true/false/nul/bool/string 5. 驼峰 6. 标识符区分大小写 */ var me string me = \"kk\" fmt.Println(me) } #2 package main import \"fmt\" var version string = \"1.0\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名规则 1. 必须由非空的unicode字符串组成、数字、_ 2. 不能以数字开头 3. 不能为go的关键字(25个) 4. 避免和go预定义标识符冲突, true/false/nul/bool/string 5. 驼峰 6. 标识符区分大小写 */ var me string me = \"kk\" fmt.Println(me) fmt.Println(version) } #3-赋值不使用,打印出来是为空的,每个类型的为空值都是不一样的 package main import \"fmt\" var version string = \"1.0\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名规则 1. 必须由非空的unicode字符串组成、数字、_ 2. 不能以数字开头 3. 不能为go的关键字(25个) 4. 避免和go预定义标识符冲突, true/false/nul/bool/string 5. 驼峰 6. 标识符区分大小写 */ var me string fmt.Println(me) me = \"kk\" fmt.Println(me) fmt.Println(version) var name, user string fmt.Println(name, user) } #4-定义多个值,并且赋值到多个值 package main import \"fmt\" var version string = \"1.0\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名规则 1. 必须由非空的unicode字符串组成、数字、_ 2. 不能以数字开头 3. 不能为go的关键字(25个) 4. 避免和go预定义标识符冲突, true/false/nul/bool/string 5. 驼峰 6. 标识符区分大小写 */ var me string fmt.Println(me) me = \"kk\" fmt.Println(me) fmt.Println(version) var name, user string = \"kk\", \"woniu\" fmt.Println(name, user) } #5-定义多个变量,并且类型是不相同的,不赋值的话打印默认会打印出两个0来. package main import \"fmt\" var version string = \"1.0\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名规则 1. 必须由非空的unicode字符串组成、数字、_ 2. 不能以数字开头 3. 不能为go的关键字(25个) 4. 避免和go预定义标识符冲突, true/false/nul/bool/string 5. 驼峰 6. 标识符区分大小写 */ var me string fmt.Println(me) me = \"kk\" fmt.Println(me) fmt.Println(version) var name, user string = \"kk\", \"woniu\" fmt.Println(name, user) var ( age int height float64 ) fmt.Println(age, height) } #6-定义多个变量并且赋值 package main import \"fmt\" var version string = \"1.0\" func main() { // 定义一个string类型的变量me /* 变量名需要满足标识符命名","date":"2020-06-18","objectID":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A81/:0:0","tags":["Golang"],"title":"Go语言基础语法入门(1)","uri":"/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A81/"},{"categories":["k8s文档汇总"],"content":"1. 前期环境准备及注意事项 首先环境用宿主机方式、docker方式、以及kubernetes方式搭建的Jenkins都是可以的.如果用kubernetes的方式的话,可以参考本博客的搭建篇. 同样如果用到的也是动态slave的方式的话,需要将宿主机的key文件、hosts文件、localtime文件都挂到容器里,后面会用到. 这里用到内网hosts解析主机,方便下面写pipeline的Jenkinsfile的时候的统一命名.以及使用ssh-keygen命令生成密钥,并且拷贝到要发布更新的服务器上,实现免密登录. 2. 配置Jenkins流水线环境 配置流水线,定义相关的变量,随后需要在Jenkinsfile里进行引用.看下图具体操作 3. 编写流水线Jenkinsfile 代码仓库使用Gitlab或者Gogs都可以,根据自己实际情况操作,需要先创建一个Jenkinsfile的目录,并且在目录下编写名为ci.jenkinsfile的流水线. #!groovy @Library ('jenkinslib@master') _ //func from sharelibrary def tools = new org.devops.tools() // 仓库地址,此处需要在主机内做hosts解析 def registryUrl = \"harbor.devops.com\" // 镜像 def image = \"${registryUrl}/${imageEndpoint}\" //定义时间戳 def TAG = \"`date +%Y-%m-%d_%H-%M`\" //env String srcUrl = \"${env.srcUrl}\" String branchName = \"${env.branchName}\" String imageEndpoint = \"${env.imageEndpoint}\" String UpdateHost = \"${env.UpdateHost}\" String ImageUrl = \"${env.ImageUrl}\" String TestImageUrl = \"${env.TestImageUrl}\" //pipeline pipeline{ agent { node { label \"xxx-jnlp\"}} stages{ stage(\"CheckOut\"){ steps{ script{ tools.PrintMes(\"获取代码\",\"green\") checkout([$class: 'GitSCM', branches: [[name: \"${branchName}\"]], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[credentialsId: 'gogs-admin-user', url: \"${srcUrl}\"]]]) } } } stage(\"BuildMirror\"){ steps{ script{ tools.PrintMes(\"构建镜像\",\"green\") withCredentials([usernamePassword(credentialsId: 'docker-auth', passwordVariable: 'HARBOR_ACCOUNT_PSW', usernameVariable: 'HARBOR_ACCOUNT_USR')]) { // some block sh \"\"\" docker login -u ${HARBOR_ACCOUNT_USR} -p ${HARBOR_ACCOUNT_PSW} ${registryUrl} docker build -t \"${image}:${TAG}\" . sleep 1 docker push \"${image}:${TAG}\" \"\"\" } } } } stage(\"UpdatedVersion\"){ steps{ script{ tools.PrintMes(\"更新版本\",\"green\") echo \"${TAG}\" sh \"ssh root@${UpdateHost} 'cd /data \u0026\u0026 \\\\cp -rf docker-compose.yaml{,.bak} \u0026\u0026 sed -i \\\"s@image: ${ImageUrl}.*@image: ${TestImageUrl}:\\\"${TAG}\\\"@\\\" docker-compose.yaml \u0026\u0026 cat docker-compose.yaml \u0026\u0026 docker-compose down -v \u0026\u0026 docker-compose up -d ' \u0026\u0026 echo 发布成功,请再确认下镜像版本!;sleep 3\" } } } } //构建后操作 post { always{ script{ println(\"always\") } } success{ script{ currentBuild.description = \"\\n 构建成功!\" } } failure{ script{ currentBuild.description = \"\\n 构建失败!\" } } aborted{ script{ currentBuild.description = \"\\n 构建取消!\" } } } } 上面的流水线引入了AnsiColor插件,所以需要先安装插件,然后再定义下Shared Groovy Libraries的共享库,内容如下,目录层级是(jenkinslib/src/org/devops/tools.groovy) tools.groovy package org.devops //格式化输出 def PrintMes(value,color){ colors = ['red' : \"\\033[40;31m \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e${value}\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c \\033[0m\", 'blue' : \"\\033[47;34m ${value} \\033[0m\", 'green' : \"\u001b[1;32m\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e${value}\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u001b[m\", 'green1' : \"\\033[40;32m \u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e${value}\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c \\033[0m\" ] ansiColor('xterm') { println(colors[color]) } } 同样需要在Jenkins上配置下Libraries的参数,请看下面的截图.凭据的话就是自己代码仓库的账号密码信息,也需要在Jenkins上配置下. 4. 补充docker登录harbor的pipeline语法生成 需要把harbor镜像仓库的账号和密码首先同样配置到凭据当中,然后到对应的job上,点击流水线,示例步骤选择:withCredentials: Bind credentials to variables 5. 最后流水线运行并验证流程 这里只是我自己调试的流水线的最终版,生产中肯定要根据自己实际的情况进行调试的.每条流水线都是要经过充分测试和调试的,不是拿过来就可以随意使用的.最后看下最终的效果. ","date":"2020-06-17","objectID":"/k8s%E5%8A%A8%E6%80%81jenkins-slave%E4%BD%BF%E7%94%A8pipeline%E5%8F%91%E5%B8%83docker%E5%BA%94%E7%94%A8/:0:0","tags":["Kubernetes"],"title":"K8s动态Jenkins Slave使用Pipeline发布Docker应用","uri":"/k8s%E5%8A%A8%E6%80%81jenkins-slave%E4%BD%BF%E7%94%A8pipeline%E5%8F%91%E5%B8%83docker%E5%BA%94%E7%94%A8/"},{"categories":["Go语言学习"],"content":"1. 初识GO语言 Go是一门开放源码的编程语言,可容易的构建简单,可靠和高效的软件 ⭐ 开发者使用编程语言的三大分类(执行速度、简易程度、开发难度): 执行速度快、编译速度慢(编译型): C,C++ 执行速度较慢、编译速度快(解释型): JAVA,.NET 执行速度慢、开发难度小(动态脚本): Python,PHP Go语言在3个条件做了平衡: 易于开发、快速编译、高效执行 特性 静态类型并具有丰富的内置类型 函数多返回值 错误处理机制 语言层并发 面向对象: 使用类型、组合、接口来实现面向对象思想 反射 CGO: 用于调用C语言实现的模块 自动垃圾回收 静态编译 交叉编译 交易部署 基于BSD协议完全开放 落地场景 ⭐ Go语言主要用于服务端开发,其定位是开发大型软件,长用于: 服务器编程: 日志处理、虚拟机处理、文件系统、分布式系统等 网络编程: Web应用、API应用、下载应用等 内存数据库 云平台 机器学习 区块链 ⭐使用Go开发的项目: Go Docker Kubernetes Prometheus ………… 常用的go的学习网站: https://github.com/golang/go/wiki/Projects https://godoc.org/ https://gowalker.org/ 2. 环境安装 ⭐下载地址: https://golang.org/dl/ https://golang.google.cn/dl/ https://golang.org/dl/#unstable 还需要单独装git工具以及VSCode编辑器,根据自己的操作系统进行安装. 3. vscode-go相关插件,不是必选,但是有一定的便利性 首先需要到GOPATH路径下创建目录,拉取GitHub上的相关代码进行部署,因为国内访问不到golang.org地址. https://github.com/golang?q=mirror\u0026type=\u0026language= #插件的github地址 git clone https://github.com/golang/net.git git clone https://github.com/golang/text.git git clone https://github.com/golang/sys.git git clone https://github.com/golang/sync.git git clone https://github.com/golang/crypto.git git clone https://github.com/golang/tools.git git clone https://github.com/golang/lint.git 此时安装其它插件,在国内可直接访问到的,下载完会自动在GOPATH路径下生成github.com目录 go get -d github.com/ramya-rao-a/go-outline go get -d github.com/acroca/go-symbols go get -d github.com/mdempsky/gocode go get -d github.com/rogpeppe/godef go get -d github.com/zmb3/gogetdoc go get -d github.com/fatih/gomodifytags go get -d sourcegraph.com/sqs/goreturns go get -d github.com/cweill/gotests/... go get -d github.com/josharian/impl go get -d github.com/haya14busa/goplay/cmd/goplay go get -d github.com/uudashr/gopkgs/cmd/gopkgs go get -d github.com/davidrjenni/reftools/cmd/fillstruct go get -d github.com/alecthomas/gometalinter go get -d github.com/go-delve/delve/cmd/dlv 下载完之后,去掉-d的参数,开始安装下载好的插件,会在电脑上生成二进制文件 go get github.com/ramya-rao-a/go-outline go get github.com/acroca/go-symbols go get github.com/mdempsky/gocode go get github.com/rogpeppe/godef go get github.com/zmb3/gogetdoc go get github.com/fatih/gomodifytags go get sourcegraph.com/sqs/goreturns go get github.com/cweill/gotests/... go get github.com/josharian/impl go get github.com/haya14busa/goplay/cmd/goplay go get github.com/uudashr/gopkgs/cmd/gopkgs go get github.com/davidrjenni/reftools/cmd/fillstruct go get github.com/alecthomas/gometalinter go get github.com/go-delve/delve/cmd/dlv gometalinter --install #安装完之后最后执行此命令安装其它工具 4. 创建目录,通过Go编写Hello World 代码内容如下 package main import \"fmt\" func main() { fmt.Println(\"Hello World!!!\") } 对代码进行编译,到go代码的所在目录下操作 pwd C:\\htgolang\\chapter01 ls go build main.go ls main.exe* main.go 编译完之后的二进制程序可以直接运行,另外编译的时候不加main.go的话,会编译整个文件夹下的所有文件,多个文件的话,只能有一个是main函数.补充构建时候的可选参数. main.exe Hello World!!! go build ls chapter01.exe* main.exe* main.go chapter01.exe Hello World!!! go build -x main.go #记录整个编译过程. go build -x -o helloworld.exe main.go #自定义名称-o参数 go run main.go #直接运行源码,会创建临时目录,进行编译并且运行 最后通过下图了解下go的程序结构. ","date":"2020-06-16","objectID":"/golang%E4%BB%8B%E7%BB%8D/:0:0","tags":["Golang"],"title":"Golang介绍","uri":"/golang%E4%BB%8B%E7%BB%8D/"},{"categories":["k8s文档汇总"],"content":"1. 部署静态Jenkins Slave 静态slave是在k8s中创建一个固定pod运行,首先需要登录Jenkins,并创建agent,获取secret信息. Deployment方式创建slave,挂载了Docker和kubectl方便在pod中构建镜像和使用kubectl命令,挂载本地的一个目录用于workspace.定义了环境变量JENKINS_URL,JENKINS_SECRET,JENKINS_AGENT_NAME,JENKINS_AGENT_WORKDIR.并且根据需求挂载时区和密钥配置. pwd /data/k8s-yaml/jenkins cat jenkinsslave.yaml --- kind: Deployment apiVersion: apps/v1 metadata: labels: k8s-app: jenkinsagent name: jenkinsagent namespace: devops spec: replicas: 1 revisionHistoryLimit: 10 selector: matchLabels: k8s-app: jenkinsagent template: metadata: labels: k8s-app: jenkinsagent namespace: devops name: jenkinsagent spec: containers: - name: jenkinsagent image: cnych/jenkins:jnlp6 imagePullPolicy: IfNotPresent tty: true resources: limits: cpu: 1000m memory: 2Gi requests: cpu: 500m memory: 1024Mi volumeMounts: - name: jenkinsagent-workdir mountPath: /home/jenkins/workspace - name: buildtools mountPath: /home/jenkins/buildtools - name: docker mountPath: /usr/bin/docker - name: docker-sock mountPath: /var/run/docker.sock - name: docker-config mountPath: /etc/docker - name: date mountPath: /etc/localtime - name: ssh mountPath: /root/.ssh - name: sshd mountPath: /etc/ssh/sshd_config - name: kubectlconfig mountPath: /home/jenkins/.kube/config - name: kubectlcmd mountPath: /usr/bin/kubectl env: - name: JENKINS_URL value: http://192.168.1.200:30080 - name: JENKINS_SECRET value: 5639cac0bf16bf15735d44bc435793417365f4dfa8fc72fb12737f3787091ae8 - name: JENKINS_AGENT_NAME value: build02 - name: JENKINS_AGENT_WORKDIR value: /home/jenkins/workspace volumes: - name: jenkinsagent-workdir hostPath: path: /data/devops/jenkins/workspace type: Directory - name: buildtools hostPath: path: /usr/local/buildtools type: Directory - name: docker hostPath: path: /usr/bin/docker - name: docker-sock hostPath: path: /var/run/docker.sock - name: docker-config hostPath: path: /etc/docker - name: date hostPath: path: /etc/localtime - name: ssh hostPath: path: /root/.ssh - name: sshd hostPath: path: /etc/ssh/sshd_config - name: kubectlconfig hostPath: path: /root/.kube/config - name: kubectlcmd hostPath: path: /usr/bin/kubectl kubectl apply -f jenkinsslave.yaml #创建配置清单命令 2. 部署动态Jenkins Slave 动态Jenkins Slave,安装kubernetes插件（安装完成后最好重启一下）。配置插件信息 系统设置 -\u003e 最后面 Cloud -\u003e增加一个云. 安装完毕后,点击 Manage Jenkins —\u003e Configure System —\u003e (拖到最下方),如果有 Add a new cloud —\u003e 选择 Kubernetes,然后填写 Kubernetes和Jenkins配置信息即可,但是最新版本的Kubernetes插件将配置单独放置到了一个页面中 此时需要点击 a separate configuration page这个链接,跳转到 Configure Cloud 页面 在该页面我们可以点击 Add a new cloud -\u003e 选择 Kubernetes，然后填写 Kubernetes 和 Jenkins 配置信息: 注意namespace,这里填devops,然后点击Test Connection,如果出现Connection test successful的提示信息证明Jenkins已经可以和Kubernetes系统正常通信了,然后下方的 Jenkins URL地址: http://jenkins.devops.svc.cluster.local:30080,这里的格式为:服务名.namespace.svc.cluster.local:30080, 根据上面创建的jenkins的服务名填写.通道地址jenkins.devops.svc.cluster.local:30081是Jenkins Slave使用的端口. 配置Pod Template,其实就是配置Jenkins Slave运行的Pod模板,命名空间我们同样使用devops,Labels这里也非常重要,对于后面执行Job的时候需要用到该值,然后我们这里使用的是cnych/jenkins:jnlp6这个镜像,这个镜像是在官方的jnlp镜像基础上定制的,有docker、kubectl等一些实用的工具 ⚠注意⚠ 容器的名称必须是jnlp,这是默认拉起的容器,另外需要将Command to run和Arguments to pass to the command的值都删除掉,否则会失败. 然后我们这里需要在下面挂载几个主机目录,一个是 /var/run/docker.sock,该文件是用于Pod中的容器能够共享宿主机的Docker,这就是大家说的docker in docker的方式，Docker二进制文件已经打包到上面的镜像中了,另外一个目录下/root/.kube目录,我们将这个目录挂载到容器的/root/.kube目录下面这是为了让我们能够在Pod的容器中能够使用 kubectl工具来访问我们的Kubernetes服务,方便我们后面在Slave Pod部署Kubernetes应用.另外根据自己实际情况需求,也可以挂载时区,hosts等主机目录,权限最好更改为1000. 另外如果在配置了后运行Slave Pod的时候出现了权限问题,这是因为Jenkins Slave Pod中没有配置权限,所以需要配置上ServiceAccount,在Slave Pod配置的地方点击下面的高级,添加上对应的ServiceAccount即可,以及顺便指定下工作卷所在的空间,应该是保存job的构建数据的. 3. 动态Jenkins Slave测试 Kubernetes插件的配置工作完成了,接下来我们就来添加一个Job任务,看是否能够在 Slave Pod中执行,任务执行完成后看Pod是否会被销毁 在Jenkins首页点击create new jobs,创建一个测试的任务,输入任务名称,然后我们选择Freestyle project类型的任务,注意在下面的Label Expression这里要填入ydzs-jnlp,就是前面我们配置的Slave Pod中的Label,这两个地方必须保持一致 然后往下拉,在 Build区域选择Execute shell 然后输入要测试用的命令,最后点保存. echo \"测试 Kubernetes 动态生成 jenkins slave\" echo \"==============docker in docker===========\" docker info echo \"=============kubectl=","date":"2020-06-15","objectID":"/%E5%8D%95%E6%9C%BAk8s%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81jenkins-slave/:0:0","tags":["Kubernetes"],"title":"单机K8s部署静态和动态Jenkins Slave","uri":"/%E5%8D%95%E6%9C%BAk8s%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%92%8C%E5%8A%A8%E6%80%81jenkins-slave/"},{"categories":["Docker容器内容"],"content":"1. Gogs简单介绍 Gogs简单介绍 什么是Gogs? Gogs 是一款极易搭建的自助 Git 服务。 开发目的: Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助Git服务.使用Go语言开发使得Gogs能够通过独立的二进制分发, 并且支持Go语言支持的所有平台,包括 Linux、Mac OS X、Windows以及ARM平台 2. Gogs的docker环境及部署流程 docker和compose的安装此处就省略,基于以上环境的基础上,直接部署 pwd /root/gogs-project 配置docker-compose cat docker-compose.yaml version: '2.3' services: mysql-gogs: container_name: mysql-gogs image: mysql:5.7 restart: always volumes: - /data/mysql:/var/lib/mysql - /data/conf:/etc/mysql/conf.d environment: MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD} MYSQL_DATABASE: ${MYSQL_DATABASE} MYSQL_USER: ${MYSQL_USER} MYSQL_PASSWORD: ${MYSQL_PASSWORD} ports: - \"${MYSQL_PORT}:3306\" networks: - gogs gogs: container_name: gogs image: gogs/gogs:0.11.91 restart: always depends_on: - mysql-gogs ports: - \"${SSH_PORT}:22\" - \"${GOGS_PORT}:3000\" volumes: - /data/gogs-data:/data links: - mysql-gogs environment: - \"RUN_CROUD=true\" - SSH_PORT=${SSH_PORT} networks: - gogs networks: gogs: driver: bridge volumes: gogs-data: driver: local mysql-data: driver: local 上面用到的环境变量需放在文件名为.env的文件,并保证与docker-compose.yaml文件在同一目录下,内容如下: cat .env MYSQL_ROOT_PASSWORD=mysql_root_password MYSQL_DATABASE=gogs MYSQL_USER=gogs MYSQL_PASSWORD=gogs_password GOGS_PORT=3000 SSH_PORT=10022 MYSQL_PORT=3306 执行命令启动,并且验证是否启动成功 docker-compose up -d docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bc08f4a4a4cc gogs/gogs:0.11.91 \"/app/gogs/docker/st…\" 12 days ago Up 12 days 0.0.0.0:3000-\u003e3000/tcp, 0.0.0.0:10022-\u003e22/tcp gogs b8ed2f175889 mysql:5.7 \"docker-entrypoint.s…\" 2 weeks ago Up 12 days 0.0.0.0:3306-\u003e3306/tcp, 33060/tcp mysql-gogs 2. HTTP运行Gogs 第一次在浏览器运行Gogs会需要填写一些初始化数据库配置等参数. 如下图: yum安装nginx并且配置实现反代 两套配置自己根据需求做调整,也可以自定义 #server { # listen 80; ## listen for ipv4 # server_name gogs.domain.com; # return 301 https://$server_name$request_uri; #} server { charset utf-8; client_max_body_size 300M; listen 80; # 或者 443，如果你使用 HTTPS 的话 # SSL support # ssl on; # ssl_certificate ./ssl/fullchain.cer; # ssl_certificate_key ./ssl/domain.com.key; server_name gogs.domain.com; location / { # 如果你希望通过子路径访问，此处修改为子路径，注意以 / 开头并以 / 结束 proxy_pass http://127.0.0.1:3000/; } } server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { proxy_pass http://127.0.0.1:3000/; } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } 3. 部署过程参考文档 参考文档如下,向各位大佬学习 https://curder.gitbooks.io/blog/others/user-docker-deploy-gogs.html?q= https://github.com/Unknwon/wuwen.org/issues/12 https://blog.csdn.net/lcr_happy/article/details/103193958 https://clonote.com/archives/1552356953819 https://my.oschina.net/xsh1208/blog/3019458 #官方及其它使用文档如下: https://gogs.io/docs/installation/install_from_binary https://www.cnblogs.com/Sungeek/p/9203038.html ","date":"2020-06-12","objectID":"/docker-compose%E5%AE%9E%E7%8E%B0gogs%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/:0:0","tags":["Docker"],"title":"Docker Compose实现Gogs服务部署","uri":"/docker-compose%E5%AE%9E%E7%8E%B0gogs%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2/"},{"categories":["k8s文档汇总"],"content":"1. Dashboard前期部署 v1.16.2版本的k8s需要安装最新的2.0+ 版本Dashboard pwd /data/k8s-yaml/dashboard wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta5/aio/deploy/recommended.yaml 修改Service为NodePort类型,并且固定端口. vim recommended.yaml ...... apiVersion: v1 metadata: labels: k8s-app: kubernetes-dashboard name: kubernetes-dashboard namespace: kubernetes-dashboard spec: ports: - port: 443 targetPort: 8443 nodePort: 31666 #固定端口为31666,外部访问的. selector: k8s-app: kubernetes-dashboard type: NodePort #加上type=NodePort变成NodePort类型的服务 ...... 直接创建,新版的Dashboard默认安装在kubernetes-dashboard命名空间 kubectl apply -f recommended.yaml kubectl get pods -n kubernetes-dashboard -l k8s-app=kubernetes-dashboard NAME READY STATUS RESTARTS AGE kubernetes-dashboard-6b86b44f87-xhktr 1/1 Running 0 9h get svc -n kubernetes-dashboard NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE dashboard-metrics-scraper ClusterIP 10.96.150.213 \u003cnone\u003e 8000/TCP 9h kubernetes-dashboard NodePort 10.103.188.75 \u003cnone\u003e 443:31666/TCP 9h 2. Dashboard修改并支持chrome浏览器访问 要使用https方式,Chrome正常是不生效,下面修改,使其支持Chrome pwd /data/k8s-yaml/dashboard mkdir key \u0026\u0026 cd key #生成证书 openssl genrsa -out dashboard.key 2048 openssl req -new -out dashboard.csr -key dashboard.key -subj '/CN=10.8.8.8' openssl x509 -req -in dashboard.csr -signkey dashboard.key -out dashboard.crt #删除原有的证书secret,提供新老两种命名空间操作. kubectl delete secret kubernetes-dashboard-certs -n kube-system kubectl delete secret kubernetes-dashboard-certs -n kubernetes-dashboard #创建新的证书secret kubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.key --from-file=dashboard.crt -n kube-system #创建新的证书secret kubectl create secret generic kubernetes-dashboard-certs --from-file=dashboard.key --from-file=dashboard.crt -n kubernetes-dashboard #查看pod kubectl get pod -n kube-system kubectl get pod -n kubernetes-dashboard #重启pod,记得要重启两个pod. kubectl delete pod \u003cpod name\u003e -n kube-system kubectl delete pod \u003cpod name\u003e -n kubernetes-dashboard kubectl delete pod dashboard-metrics-scraper-xxx -n xx kubectl delete pod kubernetes-dashboard-xxx -n xxx #最后验证重启成功 [root@kubernetes-master dashboard]# kubectl get pods -n kubernetes-dashboard NAME READY STATUS RESTARTS AGE dashboard-metrics-scraper-76585494d8-wlnrm 1/1 Running 0 9h kubernetes-dashboard-6b86b44f87-xhktr 1/1 Running 0 9h 3. 创建全局所有权用户 创建一个具有全局所有权限的用户来登录Dashboard: (admin.yaml) pwd /data/k8s-yaml/dashboard cat admin.yaml kind: ClusterRoleBinding apiVersion: rbac.authorization.k8s.io/v1beta1 metadata: name: admin annotations: rbac.authorization.kubernetes.io/autoupdate: \"true\" roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.io subjects: - kind: ServiceAccount name: admin namespace: kubernetes-dashboard --- apiVersion: v1 kind: ServiceAccount metadata: name: admin namespace: kubernetes-dashboard 执行创建操作,用base64解码后的字符串作为 token 登录Dashboard,新版本新增了暗黑模式 kubectl apply -f admin.yaml kubectl get secret -n kubernetes-dashboard|grep admin-token admin-token-p28x5 kubernetes.io/service-account-token 3 10h kubectl get secret admin-token-p28x5 -o jsonpath={.data.token} -n kubernetes-dashboard |base64 -d #会生成一串很长的base64后的字符串 ","date":"2020-06-12","objectID":"/kubernetes%E9%83%A8%E7%BD%B2dashboard%E5%B9%B6%E6%94%AF%E6%8C%81chrome%E8%AE%BF%E9%97%AE/:0:0","tags":["Kubernetes"],"title":"Kubernetes部署Dashboard--并支持Chrome浏览器","uri":"/kubernetes%E9%83%A8%E7%BD%B2dashboard%E5%B9%B6%E6%94%AF%E6%8C%81chrome%E8%AE%BF%E9%97%AE/"},{"categories":["k8s文档汇总"],"content":"No.1 kubeadm安装单机版k8s前期准备 1个节点,Centos7.7系统,在节点上添加hosts信息 cat /etc/hosts 10.8.8.8 kubernetes-master 禁用防火墙,并且禁用SELINUX systemctl stop firewalld systemctl disable firewalld setenforce 0 sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config 由于开启内核 ipv4 转发需加载 br_netfilter 模块,并创建文件/etc/sysctl.d/k8s.conf modprobe br_netfilter cat \u003c\u003c EOF \u003e /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 EOF sysctl -p /etc/sysctl.d/k8s.conf 安装 ipvs,创建脚本,保证在节点重启后能自动加载所需模块. cat \u003e /etc/sysconfig/modules/ipvs.modules \u003c\u003cEOF #!/bin/bash modprobe -- ip_vs modprobe -- ip_vs_rr modprobe -- ip_vs_wrr modprobe -- ip_vs_sh modprobe -- nf_conntrack_ipv4 EOF chmod 755 /etc/sysconfig/modules/ipvs.modules \u0026\u0026 bash /etc/sysconfig/modules/ipvs.modules \u0026\u0026 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 确保节点上已安装 ipset 软件包,为便于查看 ipvs 的代理规则,安装管理工具 ipvsadm,同步服务器时间,公有云基本都会自带此功能 yum install -y ipset ipvsadm yum install chrony -y systemctl enable chronyd systemctl start chronyd chronyc sources 关闭swap分区相关操作,有的公有云同样也已经禁用,修改/etc/sysctl.d/k8s.conf添加下面一行,docker自动化安装部分参考本博客 swapoff -a vm.swappiness=0 sysctl -p /etc/sysctl.d/k8s.conf https://currylinux.github.io/docker%E5%92%8C%E5%AE%83%E5%85%84%E5%BC%9Fdockerer_compose/ cgroup 驱动以及配置Docker镜像,和指定/data/docker目录为Docker Root Dir,启动 Docker并设置开机自启 由于默认情况下kubelet使用的cgroupdriver是systemd,所以需要保持docker和kubelet的 cgroupdriver一致,我们这里修改docker的cgroupdriver=systemd.如果不修改docker则需要修改kubelet的启动配置,需要保证两者一致. mkdir -p /etc/docker cat /etc/docker/daemon.json { \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"registry-mirrors\" : [ \"https://mirror.gcr.io\", #国外使用此仓库 \"https://ot2k4d59.mirror.aliyuncs.com/\" #国内使用此仓库 ], \"graph\": \"/data/docker\" } systemctl start docker systemctl enable docker 继续来安装 Kubeadm,通过指定yum源的方式来进行安装.并且推荐国内外两种源的方式 国外yum源: cat \u003c\u003cEOF \u003e /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg EOF ------------------------------------------------------------------------ 国内yum源: cat \u003c\u003cEOF \u003e /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=0 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF 然后安装 kubeadm、kubelet、kubectl,查看版本是否正确,并将kubelet设置成开机启动 --disableexcludes 禁掉除了kubernetes之外的别的仓库 yum install -y kubelet-1.16.2 kubeadm-1.16.2 kubectl-1.16.2 --disableexcludes=kubernetes kubeadm version systemctl enable --now kubelet No.2 kubeadm初始化相关步骤 初始化集群,在master节点配置kubeadm初始化文件,可以通过如下命令导出默认的初始化配置,并根据需求修改配置,flannel 网络插件需要将networking.podSubnet设为10.244.0.0/16 kubeadm config print init-defaults \u003e kubeadm.yaml cat kubeadm.yaml apiVersion: kubeadm.k8s.io/v1beta2 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authentication kind: InitConfiguration localAPIEndpoint: advertiseAddress: 10.8.8.8 #apiserver节点内网IP bindPort: 6443 nodeRegistration: criSocket: /var/run/dockershim.sock name: kubernetes-master #默认读取当前master节点的hostname taints: - effect: NoSchedule key: node-role.kubernetes.io/master --- apiServer: timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta2 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controllerManager: {} dns: type: CoreDNS etcd: local: dataDir: /var/lib/etcd imageRepository: k8s.gcr.io #默认为google镜像仓库 imageRepository: registry.aliyuncs.com/google_containers #国内修改成阿里镜像源 kind: ClusterConfiguration kubernetesVersion: v1.16.0 networking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 #Pod网段,flannel插件需要使用这个网段 serviceSubnet: 10.96.0.0/12 scheduler: {} --- apiVersion: kubeproxy.config.k8s.io/v1alpha1 kind: KubeProxyCon","date":"2020-06-12","objectID":"/k8s%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2jenkins/:0:0","tags":["Kubernetes"],"title":"K8s单机部署Jenkins","uri":"/k8s%E5%8D%95%E6%9C%BA%E9%83%A8%E7%BD%B2jenkins/"},{"categories":["Docker容器内容"],"content":"No.1 Nexus 基本概念之组件 简单说明下Nexus,理解为私服仓库:本地maven私服加快构建速度 代理仓库:将公网等第三方提供的仓库代理到本地. 组件的相关概念,组件通常是各种文件的存放,具体见下图1和图2的文字介绍. No.2 Nexus 基本概念之资产 Assets-资产: 简单理解Maven当中的pom算是资产的一部分,包含元数据的重要补充. pom存档文件是与jar/war包组件相关联的资产. 具体了解请见下图的文字介绍. No.3 Nexus 仓库管理 仓库格式简单介绍,详细内容见下图1文字介绍. 下载机制,Maven从存储库下载组件同时,也会下载该组件的POM.参考下图2文字介绍. 中央仓库相关概念总结:组件元数据,释放稳定性,组件安全,性能.参考下图3文字介绍. No.4 准备Nexus compose文件 参考docker官方的compose的相关说明,并且辅助相关nexus博客进行操作. 此步骤操作前,需要安装docker和docker_compose,可以参考我博客里的安装步骤. compose相关内容一并附上: [root@xxx nexus]# cat docker-compose.yml version: \"3.8\" services: nexus3: restart: always image: sonatype/nexus3 container_name: nexus3 ports: - \"80:8081\" volumes: - data:/nexus-data logging: driver: \"json-file\" options: max-size: \"200k\" max-file: \"10\" volumes: data: No.5 启动Nexus,并验证成功与否 [root@xxx nexus]# docker-compose up -d [root@xxx nexus]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES eeb6a8633273 sonatype/nexus3 \"sh -c ${SONATYPE_DI…\" About an hour ago Up About an hour 0.0.0.0:80-\u003e8081/tcp nexus3 验证安装是否成功: 地址:http://ip:port/ 用户名: admin 密码: admin123 新版本查看密码命令,并且将拿到的密码改为上面的密码: [root@sonarqube nexus]# cat /var/lib/docker/volumes/nexus_data/_data/admin.password de5bf74d-6340-43f8-8361-0f861833ccd2 参考文档 docker_compose官方文档: https://docs.docker.com/compose/compose-file/ nexus搭建maven私服: https://www.jianshu.com/p/62483b0505a5 Compose部署Nexus: https://blog.csdn.net/tiancxz/article/details/104197060 ","date":"2020-06-04","objectID":"/docker-compose%E9%83%A8%E7%BD%B2nexus/:0:0","tags":["Docker"],"title":"Docker Compose部署Nexus","uri":"/docker-compose%E9%83%A8%E7%BD%B2nexus/"},{"categories":["Docker容器内容"],"content":"No.1 脚本化部署安装docker [root@xxx ~]# cat docker.sh #!/bin/bash DOCKER_VERSION=docker-ce-18.09.9 DOCKER_CLIENT=docker-ce-cli-18.09.9 # remove old version sudo yum remove -y docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-selinux \\ docker-engine-selinux \\ docker-engine #remove all docker data sudo rm -rf /var/lib/docker #preinstall utils sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 # add repository sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # make cache sudo yum makecache fast # install the latest stable version of docker yum list docker-ce --showduplicates | sort -r yum install -y ${DOCKER_VERSION} ${DOCKER_CLIENT} containerd.io # start deamon and enable auto start when power on sudo systemctl enable docker --now if [ $? = 0 ];then echo \"docker部署成功,请开始你的表演!\" else echo \"docker部署失败,请检查配置!\" \u0026\u0026 exit 2 fi 使用说明:直接将此脚本复制到Linux服务器上运行. 最后输入命令systemctl status docker,进行验证! No.2 手动安装Docker_Compose 参考docker官方文档步骤进行: https://docs.docker.com/compose/install/ 下载docker-compose稳定版本: sudo curl -L \"https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 将可执行权限应用于二进制文件: sudo chmod +x /usr/local/bin/docker-compose 做软链接进行路径指向: sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 测试安装是否成功: docker-compose -v docker-compose -h ","date":"2020-06-04","objectID":"/docker%E5%92%8Cdocker-compose%E5%AE%89%E8%A3%85/:0:0","tags":["Docker"],"title":"Docker和Docker Compose安装","uri":"/docker%E5%92%8Cdocker-compose%E5%AE%89%E8%A3%85/"},{"categories":["教程"],"content":"第一章 简单说明 首先简单说明下,搭建过程容易,重点是主题的选择,下面也会附上我使用的主题地址. 有一点Linux基础的话,相对操作要容易一些.没有相关基础的,请认真看下搭建视频. 搭建的过程可能会遇到不少问题,希望不要放弃这个学习的过程. 第二章 搭建视频连接 亲测可行的B站视频连接: https://www.bilibili.com/video/BV1Yb411a7ty/?spm_id_from=333.788.videocard.0 只要正常按照此视频步骤搭建都可以轻松成功,国内的朋友可以通过码云(gitee.com)的方式也尝试下. 第三章 初始化hugo到github的简单步骤: 初始化命令: hugo --theme=LoveIt --baseUrl=\"https://currylinux.github.io/\" --buildDrafts 进入到此目录下: C:\\USER\\XXblog\\public git init git commit -m \"Hugo第一次提交博客\" git remote add origin https://github.com/currylinux/currylinux.github.io.git git push -u origin master 更新文章或其它内容到Github: 首先用Typora或者VScode打开要编辑的博客文章,修改完之后并保存. 使用本地预览命令: hugo server -D 进行查看本地是否变更,并将draft里的true改为false 继续在当前/目录下操作,提交git本地仓库: git add . \u0026\u0026 git commit -m \"add new post :xxx\" 运行hugo将修改更新到public目录: hugo 进入public目录,git一条龙(本地提交+发布到GitHub Pages上): cd public git add . git commit -m \"xx**xx\" git push 最后访问自己的博客地址,并且验证效果! 相关参考文献 博客模板使用地址: https://github.com/dillonzq/LoveIt/ 参考搭建视频博主博客: https://www.codesheep.cn LoveIt使用手册地址: https://hugoloveit.com/zh-cn/posts/ Hugo中文文档: https://www.gohugo.org/ Hugo英文官方文档: https://gohugo.io/documentation/ 写文章同步更新GitHub: http://xmasuhai.xyz/post/hugo/hugo%E5%85%A5%E9%97%A84%E5%86%99%E6%96%87%E7%AB%A0%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0github_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B/ ","date":"2020-06-04","objectID":"/hugo%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9Eblog/:0:0","tags":["Hugo"],"title":"Hugo你的专属Blog","uri":"/hugo%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9Eblog/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \"\rHugo 主题 LoveIt\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"}]